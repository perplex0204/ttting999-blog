---
title: 'Three Years as a Software Engineer: Lessons I Wish I Knew Earlier'
description: 'Reflections on three years of professional software development, from intern to senior engineer, and the valuable lessons learned along the way.'
date: '2025-01-10'
tags: ['Career', 'Software Engineering', 'Reflection', 'Growth']
category: 'Insight'
author: 'Ting Zhang'
image: ''
draft: false
---
# THIS IS A TEST ARTICLE, ALL THE CONTENT IS GENERATED BY AI.

## 1. Code Quality Matters More Than You Think

### Early Days: Rushing to Deliver

When I first started, I was obsessed with shipping features fast. I'd write code that "worked" and move on to the next task. My pull requests were often rushed, with minimal testing and little consideration for maintainability.

### The Wake-Up Call

Six months into the job, I was asked to add a feature to code I'd written earlier. I couldn't understand my own logic. Variable names like `data1`, `temp`, and `result` told me nothing. The function was 200 lines long with nested conditionals that made my head spin.

That's when I realized: **you write code once, but you read it hundreds of times**.

### What Changed

I started following clean code principles:

- **Meaningful names**: `userData` instead of `data1`, `isValidEmail` instead of `check()`
- **Small functions**: Each function does one thing and does it well
- **Comments for "why", not "what"**: The code should explain what it does; comments explain why
- **Test coverage**: If it's not tested, it's broken

The time I spent writing cleaner code was saved tenfold when maintaining and extending it.

## 2. Communication is as Important as Technical Skills

### The Silent Developer Trap

I used to think being a good engineer meant writing excellent code in silence. I'd spend days debugging an issue alone rather than asking for help, fearing it would make me look incompetent.

### The Reality Check

During a major refactoring project, I spent three days implementing a solution, only to discover in the team review that someone had already solved a similar problem. My approach conflicted with the team's architecture decisions.

**The lesson**: You can write perfect code, but if it doesn't align with team goals or duplicates existing work, it's wasted effort.

### Better Practices

Now I:

- **Ask questions early**: "Has anyone solved something like this before?"
- **Share progress regularly**: Daily updates, even if it's "still debugging X"
- **Document decisions**: Why I chose approach A over B
- **Request code reviews proactively**: Fresh eyes catch issues I miss

The best engineers I've worked with are excellent communicators, not just excellent coders.

## 3. Performance Optimization: Measure Before You Optimize

### The Premature Optimization Mistake

Early in my career, I'd spend hours micro-optimizing code that ran once a day. I'd rewrite loops, cache everything, and use complex algorithms to save milliseconds.

Meanwhile, the real bottleneck—a database query running on every page load—went unnoticed.

### Learning to Profile

A senior engineer taught me: **"Measure first, optimize later."**

We integrated profiling tools:
- **Backend**: `cProfile` for Python, `pg_stat_statements` for PostgreSQL
- **Frontend**: Chrome DevTools Performance tab
- **Monitoring**: Prometheus + Grafana for production metrics

### Real Impact

After profiling, I discovered:

- 60% of response time came from one unoptimized MongoDB query
- A single API endpoint was called 100x more frequently than others
- Frontend bundle size had grown to 5MB due to unnecessary dependencies

Fixing these three issues improved overall performance by 70%. All my micro-optimizations combined? Maybe 2%.

**Lesson**: Profile, identify bottlenecks, then optimize where it matters.

## 4. Technical Debt is Real (and Costly)

### "We'll Fix It Later"

Every developer has said this. I certainly did. Quick hacks to meet deadlines, skipping tests because "this is just a prototype," hardcoding values because "we'll make it configurable later."

Later never came.

### The Compound Interest of Bad Code

Technical debt compounds like financial debt. That quick hack becomes a critical path. The prototype becomes production code. The hardcoded value is now referenced in 50 places.

Six months later, adding a simple feature takes a week because you're navigating a minefield of fragile code.

### Managing Technical Debt

Now I approach it like a balance sheet:

- **Track it**: Maintain a technical debt backlog
- **Estimate cost**: How much time would it take to fix?
- **Calculate impact**: What's the cost of NOT fixing it?
- **Schedule it**: Dedicate 20% of sprint time to debt reduction

Some debt is acceptable—strategic even—but it must be intentional and managed.

## 5. Learning Never Stops

### The Overwhelming Pace of Technology

When I started, I felt pressure to learn everything: every framework, every tool, every language. The tech landscape moves fast, and FOMO is real.

### Finding Focus

I learned to be strategic:

- **Depth over breadth**: Master the tools you use daily before chasing new ones
- **Learn by doing**: Build projects, not just tutorials
- **Read code**: Study how popular libraries solve problems
- **Fundamentals matter**: Algorithms, data structures, system design don't change as fast as frameworks

### My Learning System

- **Daily**: 30 minutes reading technical articles or documentation
- **Weekly**: Experiment with one new concept or tool
- **Monthly**: Deep dive into a topic (design patterns, distributed systems, etc.)
- **Quarterly**: Build a side project applying new skills

This sustainable pace has taught me more than trying to learn everything at once.

## 6. Empathy for Users and Colleagues

### Beyond the Code

Software engineering isn't just about writing code—it's about solving problems for real people.

- **Users**: They don't care about your elegant algorithm if the app is slow or confusing
- **Colleagues**: Clear documentation and readable code respect their time
- **Future you**: Your future self will thank you for writing understandable code

### User-First Thinking

I started:

- Attending user interviews
- Testing features on different devices and connection speeds
- Measuring user impact, not just technical metrics (lines of code, test coverage)

**Result**: Features that users actually love and use.

## Conclusion: The Journey Continues

Three years in, I'm still learning. The senior engineer title doesn't mean I know everything—it means I know how much I don't know, and I'm comfortable with that.

Key takeaways:

1. **Write code for humans**, not just computers
2. **Communicate early and often**
3. **Measure before you optimize**
4. **Manage technical debt intentionally**
5. **Learn strategically**, not frantically
6. **Empathize with users and colleagues**

If you're starting your career or feeling stuck, remember: every senior engineer was once a confused junior. The difference is time, mistakes, and learning from them.

What lessons have shaped your career? I'd love to hear your experiences!
